# azure-pipelines.yml (Windows self-hosted)

trigger:
  branches:
    include:
      - main

variables:
  rm: rm554983
  location: eastus
  resourceGroup: rg-sprint-Nextpark
  appPlan: planNextpark
  appName: nextpark-sprint-$(rm)
  acrName: nextparkacr$(rm)
  imageName: nextpark
  sku: B1

# Agente Windows do seu pool
pool:
  name: 'Default'

stages:
# ================== 1) INFRA ==================
- stage: criarInfra
  displayName: 'Criar infraestrutura (RG, Plan, ACR, WebApp)'
  jobs:
  - job: infra
    displayName: 'Provisionar Azure (idempotente)'
    steps:
    - task: AzureCLI@2
      displayName: 'Criar RG, Plan, ACR (admin) e WebApp (container)'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'

          $rg   = '$(resourceGroup)'
          $loc  = '$(location)'
          $plan = '$(appPlan)'
          $app  = '$(appName)'
          $acr  = '$(acrName)'
          $sku  = '$(sku)'

          # RG
          az group create -n $rg -l $loc | Out-Null

          # App Service Plan (Linux)
          $planExists = az appservice plan show -n $plan -g $rg 2>$null
          if (-not $planExists) {
            az appservice plan create -n $plan -g $rg --sku $sku --is-linux | Out-Null
            Write-Host "App Service Plan '$plan' criado."
          } else {
            Write-Host "App Service Plan '$plan' já existe."
          }

          # ACR (admin on para simplificar o deploy)
          $acrExists = az acr show -n $acr -g $rg 2>$null
          if (-not $acrExists) {
            az acr create -n $acr -g $rg -l $loc --sku Basic --admin-enabled true | Out-Null
            Write-Host "ACR '$acr' criado."
          } else {
            Write-Host "ACR '$acr' já existe."
          }

          # WebApp for Containers (imagem placeholder)
          $appExists = az webapp show -g $rg -n $app 2>$null
          if (-not $appExists) {
            az webapp create -g $rg -p $plan -n $app --deployment-container-image-name "hello-world" | Out-Null
            Write-Host "WebApp '$app' criado."
          } else {
            Write-Host "WebApp '$app' já existe."
          }

          Write-Host "Infra OK: RG=$rg PLAN=$plan ACR=$acr APP=$app"

    - task: AzureCLI@2
      displayName: 'Configurar App Settings (DB_URL/DB_USER/DB_PASS)'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          $rg  = '$(resourceGroup)'
          $app = '$(appName)'

          az webapp config appsettings set `
            -g $rg -n $app --settings `
            DB_URL="$(DB_URL)" `
            DB_USER="$(DB_USER)" `
            DB_PASS="$(DB_PASS)" | Out-Null

          Write-Host "App settings definidos."

# ================== 2) CI ==================
- stage: BuildApp
  displayName: 'Build, Testes e Publicação de Imagem'
  dependsOn: criarInfra
  jobs:
  - job: build
    displayName: 'Maven build + Docker push'
    steps:
    - powershell: |
        mvn -v
        mvn -B -ntp clean test package
      displayName: 'Build e testes Maven'

    - powershell: |
        New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
        Copy-Item -Path ".\target\*.jar" -Destination "$(Build.ArtifactStagingDirectory)" -ErrorAction SilentlyContinue
        "$(imageName):$(Build.BuildId)" | Out-File -FilePath "$(Build.ArtifactStagingDirectory)\imageTag.txt" -Encoding utf8
      displayName: 'Preparar artefatos (.jar + imageTag.txt)'

    - task: PublishPipelineArtifact@1
      displayName: 'Publicar artefatos no Azure DevOps'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'drop'
        publishLocation: 'pipeline'

    - task: AzureCLI@2
      displayName: 'Docker build e push para ACR'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          $acr = '$(acrName)'
          $img = "$(imageName):$(Build.BuildId)"

          $loginServer = az acr show -n $acr --query loginServer -o tsv
          az acr login -n $acr | Out-Null

          docker version
          docker build -t $img .
          docker tag $img "$loginServer/$img"
          docker push "$loginServer/$img"

          Write-Host "##vso[task.setvariable variable=imageTag;isOutput=true]$img"
          Write-Host "Imagem publicada: $loginServer/$img"

# ================== 3) CD ==================
- stage: deployApp
  displayName: 'Deploy no Azure Web App (Container)'
  dependsOn: BuildApp
  jobs:
  - job: deploy
    displayName: 'Atualizar container do WebApp'
    steps:
    - task: AzureCLI@2
      displayName: 'Apontar WebApp para imagem do ACR'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          $rg       = '$(resourceGroup)'
          $app      = '$(appName)'
          $acr      = '$(acrName)'
          $imageTag = '$(imageTag)'

          $loginServer = az acr show -n $acr --query loginServer -o tsv

          # Credenciais admin do ACR (criadas com --admin-enabled true)
          $acrCred = az acr credential show -n $acr | ConvertFrom-Json
          $acrUser = $acrCred.username
          $acrPass = $acrCred.passwords[0].value

          # Web Apps Linux esperam 80 por padrão; sua app expõe 8080
          az webapp config appsettings set -g $rg -n $app --settings WEBSITES_PORT=8080 | Out-Null

          az webapp config container set -g $rg -n $app `
            --docker-custom-image-name "$loginServer/$imageTag" `
            --docker-registry-server-url "https://$loginServer" `
            --docker-registry-server-user "$acrUser" `
            --docker-registry-server-password "$acrPass" | Out-Null

          Write-Host "Deploy OK: $loginServer/$imageTag"
