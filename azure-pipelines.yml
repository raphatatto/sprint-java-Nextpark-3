# azure-pipelines.yml (Windows self-hosted)

trigger:
  branches:
    include:
      - main
      - master

variables:
  rm: rm554983
  location: eastus
  resourceGroup: rg-sprint-Nextpark
  appPlan: planNextpark
  appName: nextpark-sprint-$(rm)
  acrName: nextparkacrrm554983
  imageName: nextpark
  sku: B1

pool:
  name: 'Default'  

stages:
# ================== 1) INFRA ==================
- stage: criarInfra
  displayName: 'Criar infraestrutura (RG, Plan, ACR, WebApp)'
  jobs:
  - job: infra
    displayName: 'Provisionar Azure (idempotente)'
    steps:
    # 1.1 Registrar providers necessários
    - task: AzureCLI@2
      displayName: 'Registrar providers ACR/Web (se necessário)'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          foreach ($ns in @('Microsoft.ContainerRegistry','Microsoft.Web')) {
            $state = az provider show -n $ns --query registrationState -o tsv
            if ($state -ne 'Registered') {
              Write-Host "Registrando $ns ..."
              az provider register -n $ns | Out-Null
              do {
                Start-Sleep -Seconds 5
                $state = az provider show -n $ns --query registrationState -o tsv
                Write-Host "$ns = $state"
              } until ($state -eq 'Registered')
            } else {
              Write-Host "$ns já está Registered."
            }
          }

    # 1.2 Criar RG/Plan/ACR/WebApp (idempotente)
    - task: AzureCLI@2
      displayName: 'Criar RG, Plan, ACR (admin) e WebApp (container)'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'

          $rg   = '$(resourceGroup)'
          $loc  = '$(location)'
          $plan = '$(appPlan)'
          $app  = '$(appName)'
          $acr  = '$(acrName)'
          $sku  = '$(sku)'

          # RG
          az group create -n $rg -l $loc --only-show-errors | Out-Null

          # App Service Plan (Linux)
          cmd /c "az appservice plan show -n $plan -g $rg --only-show-errors >NUL 2>&1"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Plan '$plan' não existe. Criando..."
            az appservice plan create -n $plan -g $rg --sku $sku --is-linux --only-show-errors | Out-Null
          } else {
            Write-Host "Plan '$plan' já existe."
          }

          # ACR (admin habilitado)
          cmd /c "az acr show -n $acr -g $rg --only-show-errors >NUL 2>&1"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "ACR '$acr' não existe. Criando..."
            az acr create -n $acr -g $rg -l $loc --sku Basic --admin-enabled true --only-show-errors | Out-Null
          } else {
            Write-Host "ACR '$acr' já existe."
          }

          # WebApp for Containers
          cmd /c "az webapp show -g $rg -n $app --only-show-errors >NUL 2>&1"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "WebApp '$app' não existe. Criando..."
            az webapp create -g $rg -p $plan -n $app --deployment-container-image-name "hello-world" --only-show-errors | Out-Null
          } else {
            Write-Host "WebApp '$app' já existe."
          }

          Write-Host "Infra OK: RG=$rg PLAN=$plan ACR=$acr APP=$app"

    # 1.3 App Settings com secrets
    - task: AzureCLI@2
      displayName: 'Configurar App Settings (DB_URL/DB_USER/DB_PASS)'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          $rg  = '$(resourceGroup)'
          $app = '$(appName)'

          az webapp config appsettings set `
            -g $rg -n $app --settings `
            DB_URL="$(DB_URL)" `
            DB_USER="$(DB_USER)" `
            DB_PASS="$(DB_PASS)" --only-show-errors | Out-Null

          Write-Host "App settings definidos."

# ================== 2) CI ==================
- stage: BuildApp
  displayName: 'Build, Testes e Publicação de Imagem'
  dependsOn: criarInfra
  jobs:
  - job: build
    displayName: 'Maven build + Docker push (Windows)'
    steps:

    # 2.1 Build do JAR
    - powershell: |
        mvn -v
        mvn -B -ntp clean test package
      workingDirectory: '$(Build.SourcesDirectory)'
      displayName: 'Build do JAR com Maven'

    # 2.2 Verificar se o JAR foi criado
    - powershell: |
        Write-Host "Listando conteúdo do target:"
        Get-ChildItem -Path target -Filter *.jar -Recurse
      workingDirectory: '$(Build.SourcesDirectory)'
      displayName: 'Verificar JAR gerado'

    # 2.3 Publicar resultados JUnit (facilita debug se quebrar)
    - task: PublishTestResults@2
      displayName: 'Publicar resultados de teste'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'target/surefire-reports/*.xml'
        failTaskOnFailedTests: true

    # 2.4 Publicar artefatos (JAR + imageTag)
    - powershell: |
        New-Item -ItemType Directory -Force -Path "$(Build.ArtifactStagingDirectory)" | Out-Null
        Copy-Item -Path ".\target\*.jar" -Destination "$(Build.ArtifactStagingDirectory)" -ErrorAction SilentlyContinue
        "$(imageName):$(Build.BuildId)" | Out-File -FilePath "$(Build.ArtifactStagingDirectory)\imageTag.txt" -Encoding utf8
      displayName: 'Preparar artefatos (.jar + imageTag.txt)'

    - task: PublishPipelineArtifact@1
      displayName: 'Publicar artefatos no Azure DevOps'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'drop'
        publishLocation: 'pipeline'

    # 2.5 Docker build & push no ACR (Windows, sem ACR Tasks)
    - task: AzureCLI@2
      displayName: 'Docker build & push no ACR (Windows)'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        workingDirectory: '$(Build.SourcesDirectory)'
        inlineScript: |
          $ErrorActionPreference = 'Stop'

          $acr = '$(acrName)'
          $img = "$(imageName):$(Build.BuildId)"

          # 0) Garantir que estamos na pasta do Dockerfile (YAML: workingDirectory já cuida)
          Write-Host "PWD: $(Get-Location)"

          # 1) Docker ativo
          try { docker version | Out-Null } catch {
            throw "Docker Desktop não está em execução (Engine Linux). Abra o Docker e tente novamente."
          }

          if (-not (Get-ChildItem -Path 'target' -Filter '*.jar' -ErrorAction SilentlyContinue)) {
            throw "Ainda não há JAR em .\target. Confira o passo Maven package."
          }

          # 3) Login no ACR
          $loginServer = az acr show -n $acr --query loginServer -o tsv
          az acr login -n $acr | Out-Null

          # 4) Build/Tag/Push
          docker build -t $img .
          docker tag $img "$loginServer/$img"
          docker push "$loginServer/$img"

          # 5) Exportar tag para o stage de deploy
          Write-Host "##vso[task.setvariable variable=imageTag;isOutput=true]$img"
          Write-Host "Imagem publicada: $loginServer/$img"





# ================== 3) CD ==================
- stage: deployApp
  displayName: 'Deploy no Azure Web App (Container)'
  dependsOn: BuildApp
  jobs:
  - job: deploy
    displayName: 'Atualizar container do WebApp'
    steps:
    - task: AzureCLI@2
      displayName: 'Apontar WebApp para imagem do ACR'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          $rg  = '$(resourceGroup)'
          $app = '$(appName)'
          $acr = '$(acrName)'

          # Pega a tag do stage anterior (se não vier, usa BuildId)
          $imageTag = "$(imageTag)"
          if ([string]::IsNullOrWhiteSpace($imageTag) -or $imageTag -eq '$(imageTag)') {
            $imageTag = "$(imageName):$(Build.BuildId)"
          }

          $loginServer = az acr show -n $acr --query loginServer -o tsv

          # Credenciais admin do ACR
          $acrCred = az acr credential show -n $acr | ConvertFrom-Json
          $acrUser = $acrCred.username
          $acrPass = $acrCred.passwords[0].value

          # Web Apps Linux escuta 80 por padrão; sua app expõe 8080
          az webapp config appsettings set -g $rg -n $app --settings WEBSITES_PORT=8080 | Out-Null

          $fullImage = "$loginServer/$imageTag"

          # ❗ Sem quebras com crase: tudo em UMA linha
          az webapp config container set -g $rg -n $app --docker-custom-image-name $fullImage --docker-registry-server-url "https://$loginServer" --docker-registry-server-user $acrUser --docker-registry-server-password $acrPass

          Write-Host "Deploy OK: $fullImage"

